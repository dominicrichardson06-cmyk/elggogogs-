<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>LEGO 3D — Edge-Aligned Grid + Save/Load + Expanded Parts</title>
<style>
  :root{ --bg:#f5f7fb; --fg:#0b1220; --card:#fff; --line:#e5e7eb; }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  #app{height:100%;display:grid;grid-template-columns:260px 1fr;grid-template-rows:50px 1fr;grid-template-areas:"topbar topbar" "sidebar main"}
  header{grid-area:topbar;display:flex;gap:8px;align-items:center;padding:8px 12px;background:#fff;box-shadow:0 2px 12px rgba(0,0,0,.06)}
  header .grow{flex:1}
  .btn{border:0;border-radius:10px;background:#0b1220;color:#fff;padding:6px 10px;font-weight:600;cursor:pointer}
  .dd{position:relative;display:inline-block}
  .menu{position:absolute;top:100%;right:0;background:#fff;border:1px solid var(--line);border-radius:12px;box-shadow:0 12px 28px rgba(0,0,0,.14);padding:8px;display:none;z-index:20;min-width:320px;max-height:70vh;overflow:auto}
  .menu.show{display:block}
  .sec{border:1px solid var(--line);border-radius:10px;margin:8px 0;background:#fafbfc}
  .sec h4{margin:0;padding:10px 12px;font-size:13px;background:#f1f5f9;border-bottom:1px solid var(--line);display:flex;justify-content:space-between;align-items:center;cursor:pointer}
  .sec .body{padding:8px;display:grid;grid-template-columns:1fr 1fr;gap:6px}
  .item{display:block;text-align:left;border:1px solid var(--line);background:#fff;padding:8px 10px;border-radius:8px;cursor:pointer;font-size:13px}
  .item small{color:#6b7280}
  .item:hover{background:#f8fafc}
  #sidebar{grid-area:sidebar;padding:12px;overflow:auto;background:#eef2f7;border-right:1px solid var(--line)}
  .card{background:var(--card);border-radius:12px;padding:10px;box-shadow:0 6px 18px rgba(0,0,0,.07)}
  .card + .card{margin-top:12px}
  #main{grid-area:main;position:relative}
  #c{width:100%;height:100%;display:block}
  .hint{position:absolute;left:12px;top:12px;background:rgba(0,0,0,.7);color:#fff;padding:6px 10px;border-radius:8px;font-size:12px;display:none;z-index:2}
  .dot{width:16px;height:16px;border-radius:50%;border:1px solid #cbd5e1;display:inline-block;vertical-align:middle}
  .kbd{background:#0b1220;color:#fff;border-radius:6px;padding:1px 6px;font-size:11px}
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>
</head>
<body>
<div id="app">
  <header>
    <strong>LEGO 3D — Edge-Aligned Grid</strong>
    <div class="grow"></div>

    <div class="dd">
      <button id="btnColor" class="btn">
        <span id="btnColorDot" class="dot" style="background:#0055BF"></span>
        <span id="btnColorLabel">Blue · Plastic</span> ▾
      </button>
      <div id="menuColor" class="menu" aria-label="Choose a color"></div>
    </div>

    <div class="dd">
      <button id="btnParts" class="btn">Parts ▾</button>
      <div id="menuParts" class="menu" aria-label="Choose a part"></div>
    </div>

    <button id="btnSave" class="btn" title="Download build as JSON">Save</button>
    <input id="fileIn" type="file" accept="application/json" hidden />
    <button id="btnLoad" class="btn" title="Open a JSON build file">Load</button>
  </header>

  <aside id="sidebar">
    <div class="card" style="font-size:12px;color:#6b7280;line-height:1.5">
      • Left-drag orbit · Right-drag pan · Wheel zoom<br/>
      • Pick a <b>Color</b> then <b>Part</b><br/>
      • <span class="kbd">R</span> rotate ghost · click to drop (keeps placing) · <span class="kbd">Esc</span> cancel<br/>
      • Click a part to select (blue outline) · <span class="kbd">Delete</span> removes<br/>
      • Grid squares are exactly 1×1 studs; bold line every 8 studs
    </div>
  </aside>

  <main id="main">
    <canvas id="c"></canvas>
    <div id="hint" class="hint">Placing… R rotates · click to drop · Esc cancels</div>
  </main>
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';
import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

/* ===== constants ===== */
const STUD_PITCH=8, PLATE_HEIGHT=3.2, BRICK_HEIGHT=9.6, BASE_STUDS=48;
const STUD_DIAMETER=4.8, STUD_RADIUS=STUD_DIAMETER/2, STUD_HEIGHT=1.6;
const EPS = 0.001;

/* ===== renderer & scene ===== */
const renderer=new THREE.WebGLRenderer({canvas:document.getElementById('c'),antialias:true});
renderer.setPixelRatio(devicePixelRatio);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.physicallyCorrectLights = true;

const scene=new THREE.Scene(); scene.background=new THREE.Color(0xf5f7fb);
const camera=new THREE.PerspectiveCamera(45,2,0.1,6000); camera.position.set(230,230,260);
const controls=new OrbitControls(camera,renderer.domElement);
controls.enableDamping=true; controls.dampingFactor=.07;

scene.add(new THREE.HemisphereLight(0xffffff,0xb0b8c2,0.9));
const sun=new THREE.DirectionalLight(0xffffff,1.0); sun.position.set(300,420,250); scene.add(sun);

/* bright room (helps glass readability) */
(function addRoom(){
  const room = new THREE.Mesh(
    new THREE.BoxGeometry(2000,1200,2000),
    new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.BackSide })
  );
  room.position.y = 300;
  scene.add(room);
})();

/* ===== baseplate ===== */
const baseplate=new THREE.Group(); scene.add(baseplate);
const plate=new THREE.Mesh(
  new THREE.BoxGeometry(BASE_STUDS*STUD_PITCH, PLATE_HEIGHT, BASE_STUDS*STUD_PITCH),
  new THREE.MeshStandardMaterial({color:0x9ecae1,roughness:0.95,metalness:0})
);
plate.position.y=PLATE_HEIGHT/2; baseplate.add(plate);

/* ===== edge-aligned floor grid (1×1 cells; bold every 8) ===== */
function makeStudEdgeGrid(studs, pitch, minorColor=0xe3e7ee, majorColor=0x94a3b8, majorEvery=8){
  const half = (studs * pitch) / 2;
  const minorVerts = [];
  const majorVerts = [];
  for(let j=0; j<=studs; j++){
    const p = -half + j*pitch;
    const tgt = (j % majorEvery === 0) ? majorVerts : minorVerts;
    tgt.push(p,0,-half, p,0, half);  // vertical
    tgt.push(-half,0,p, half,0, p);  // horizontal
  }
  const group = new THREE.Group();
  if(minorVerts.length){
    const g = new THREE.BufferGeometry();
    g.setAttribute('position', new THREE.Float32BufferAttribute(minorVerts,3));
    const lines = new THREE.LineSegments(g, new THREE.LineBasicMaterial({ color: minorColor }));
    lines.position.y = PLATE_HEIGHT + 0.01;
    group.add(lines);
  }
  if(majorVerts.length){
    const g2 = new THREE.BufferGeometry();
    g2.setAttribute('position', new THREE.Float32BufferAttribute(majorVerts,3));
    const lines2 = new THREE.LineSegments(g2, new THREE.LineBasicMaterial({ color: majorColor }));
    lines2.position.y = PLATE_HEIGHT + 0.02;
    group.add(lines2);
  }
  return group;
}
baseplate.add(makeStudEdgeGrid(BASE_STUDS, STUD_PITCH));

/* picking plane */
const pickPlane=new THREE.Mesh(new THREE.PlaneGeometry(4000,4000),new THREE.MeshBasicMaterial({visible:false}));
pickPlane.rotateX(-Math.PI/2); pickPlane.position.y=PLATE_HEIGHT; scene.add(pickPlane);

const modelRoot=new THREE.Group(); scene.add(modelRoot);

/* ===== catalog (grouped, expanded) ===== */
const SECTIONS = [
  { title: 'Brick › 1× Brick', items: [
    { id:'3005', name:'1×1', studs:[1,1], height:BRICK_HEIGHT },
    { id:'3004', name:'1×2', studs:[1,2], height:BRICK_HEIGHT },
    { id:'3622', name:'1×3', studs:[1,3], height:BRICK_HEIGHT },
    { id:'3010', name:'1×4', studs:[1,4], height:BRICK_HEIGHT },
    { id:'3009', name:'1×6', studs:[1,6], height:BRICK_HEIGHT },
    { id:'3008', name:'1×8', studs:[1,8], height:BRICK_HEIGHT },
    { id:'6111', name:'1×10', studs:[1,10], height:BRICK_HEIGHT },
    { id:'6112', name:'1×12', studs:[1,12], height:BRICK_HEIGHT },
    { id:'2465', name:'1×16', studs:[1,16], height:BRICK_HEIGHT },
    { id:'2357', name:'2×2 Corner', studs:[2,2], height:BRICK_HEIGHT, mask:'corner' }
  ]},
  { title: 'Brick › 2× Brick', items: [
    { id:'3003', name:'2×2', studs:[2,2], height:BRICK_HEIGHT },
    { id:'3002', name:'2×3', studs:[2,3], height:BRICK_HEIGHT },
    { id:'3001', name:'2×4', studs:[2,4], height:BRICK_HEIGHT },
    { id:'2456', name:'2×6', studs:[2,6], height:BRICK_HEIGHT },
    { id:'3007', name:'2×8', studs:[2,8], height:BRICK_HEIGHT },
    { id:'3006', name:'2×10', studs:[2,10], height:BRICK_HEIGHT }
  ]},
  { title: 'Brick › Tall Brick', items: [
    { id:'14716', name:'1×1×3', studs:[1,1], height:BRICK_HEIGHT*3 },
    { id:'2453',  name:'1×1×5', studs:[1,1], height:BRICK_HEIGHT*5 },
    { id:'3245',  name:'1×2×2', studs:[1,2], height:BRICK_HEIGHT*2 },
    { id:'22886', name:'1×2×3', studs:[1,2], height:BRICK_HEIGHT*3 },
    { id:'2454',  name:'1×2×5', studs:[1,2], height:BRICK_HEIGHT*5 },
    { id:'30145', name:'2×2×3', studs:[2,2], height:BRICK_HEIGHT*3 },
    { id:'49311', name:'1×4×3', studs:[1,4], height:BRICK_HEIGHT*3 }
  ]},
  { title: 'Brick › Hollow Brick', items: [
    { id:'3065',  name:'1×2 Hollow',   studs:[1,2], height:BRICK_HEIGHT, hollow:true },
    { id:'46212', name:'1×2×5 Hollow', studs:[1,2], height:BRICK_HEIGHT*5, hollow:true },
    { id:'3066',  name:'1×4 Hollow',   studs:[1,4], height:BRICK_HEIGHT, hollow:true }
  ]},
  { title: 'Plate › 1× Plate', items: [
    { id:'3024', name:'1×1', studs:[1,1], height:PLATE_HEIGHT },
    { id:'3023', name:'1×2', studs:[1,2], height:PLATE_HEIGHT },
    { id:'3623', name:'1×3', studs:[1,3], height:PLATE_HEIGHT },
    { id:'3710', name:'1×4', studs:[1,4], height:PLATE_HEIGHT },
    { id:'78329',name:'1×5', studs:[1,5], height:PLATE_HEIGHT },
    { id:'3666', name:'1×6', studs:[1,6], height:PLATE_HEIGHT },
    { id:'3460', name:'1×8', studs:[1,8], height:PLATE_HEIGHT },
    { id:'4477', name:'1×10', studs:[1,10], height:PLATE_HEIGHT },
    { id:'60479',name:'1×12', studs:[1,12], height:PLATE_HEIGHT },
    { id:'2420', name:'2×2 Corner', studs:[2,2], height:PLATE_HEIGHT, mask:'corner' },
    { id:'77844',name:'3×3 Corner', studs:[3,3], height:PLATE_HEIGHT, mask:'corner' },
    { id:'15397',name:'3×3 Cross', studs:[3,3], height:PLATE_HEIGHT, mask:'cross' },
    { id:'73831',name:'2×3 w/ Cutout', studs:[2,3], height:PLATE_HEIGHT, mask:'cutout_corner' },
    { id:'64799',name:'4×4 w/ Cutout', studs:[4,4], height:PLATE_HEIGHT, mask:'cutout_center_2x2' }
  ]},
  { title: 'Plate › 2× Plate', items: [
    { id:'3022', name:'2×2', studs:[2,2], height:PLATE_HEIGHT },
    { id:'3021', name:'2×3', studs:[2,3], height:PLATE_HEIGHT },
    { id:'3020', name:'2×4', studs:[2,4], height:PLATE_HEIGHT },
    { id:'3795', name:'2×6', studs:[2,6], height:PLATE_HEIGHT },
    { id:'3034', name:'2×8', studs:[2,8], height:PLATE_HEIGHT },
    { id:'3832', name:'2×10', studs:[2,10], height:PLATE_HEIGHT },
    { id:'2445', name:'2×12', studs:[2,12], height:PLATE_HEIGHT },
    { id:'91988',name:'2×14', studs:[2,14], height:PLATE_HEIGHT },
    { id:'4282', name:'2×16', studs:[2,16], height:PLATE_HEIGHT },
    { id:'2639', name:'4×4 Corner', studs:[4,4], height:PLATE_HEIGHT, mask:'corner_quadrant' }
  ]},
  { title: 'Plate › Large Plate', items: [
    { id:'11212',name:'3×3', studs:[3,3], height:PLATE_HEIGHT },
    { id:'3031', name:'4×4', studs:[4,4], height:PLATE_HEIGHT },
    { id:'3032', name:'4×6', studs:[4,6], height:PLATE_HEIGHT },
    { id:'3035', name:'4×8', studs:[4,8], height:PLATE_HEIGHT },
    { id:'3030', name:'4×10', studs:[4,10], height:PLATE_HEIGHT },
    { id:'3029', name:'4×12', studs:[4,12], height:PLATE_HEIGHT },
    { id:'3958', name:'6×6', studs:[6,6], height:PLATE_HEIGHT },
    { id:'3036', name:'6×8', studs:[6,8], height:PLATE_HEIGHT },
    { id:'3033', name:'6×10', studs:[6,10], height:PLATE_HEIGHT },
    { id:'3028', name:'6×12', studs:[6,12], height:PLATE_HEIGHT },
    { id:'3456', name:'6×14', studs:[6,14], height:PLATE_HEIGHT },
    { id:'3027', name:'6×16', studs:[6,16], height:PLATE_HEIGHT },
    { id:'41539',name:'8×8', studs:[8,8], height:PLATE_HEIGHT },
    { id:'92438',name:'8×16', studs:[8,16], height:PLATE_HEIGHT }
  ]},
  { title: 'Tile (no studs on top)', items: [
    { id:'3070',  name:'1×1 Tile', studs:[1,1], height:PLATE_HEIGHT, tile:true },
    { id:'3069',  name:'1×2 Tile', studs:[1,2], height:PLATE_HEIGHT, tile:true },
    { id:'63864', name:'1×3 Tile', studs:[1,3], height:PLATE_HEIGHT, tile:true },
    { id:'2431',  name:'1×4 Tile', studs:[1,4], height:PLATE_HEIGHT, tile:true },
    { id:'6636',  name:'1×6 Tile', studs:[1,6], height:PLATE_HEIGHT, tile:true },
    { id:'4162',  name:'1×8 Tile', studs:[1,8], height:PLATE_HEIGHT, tile:true },
    { id:'14719', name:'2×2 Tile, Corner', studs:[2,2], height:PLATE_HEIGHT, tile:true, mask:'corner' },
    { id:'3068',  name:'2×2 Tile', studs:[2,2], height:PLATE_HEIGHT, tile:true },
    { id:'26603', name:'2×3 Tile', studs:[2,3], height:PLATE_HEIGHT, tile:true },
    { id:'87079', name:'2×4 Tile', studs:[2,4], height:PLATE_HEIGHT, tile:true },
    { id:'69729', name:'2×6 Tile', studs:[2,6], height:PLATE_HEIGHT, tile:true },
    { id:'1751N', name:'4×4 Tile', studs:[4,4], height:PLATE_HEIGHT, tile:true },
    { id:'10202', name:'6×6 Tile', studs:[6,6], height:PLATE_HEIGHT, tile:true },
    { id:'8x16T', name:'8×16 Tile', studs:[8,16], height:PLATE_HEIGHT, tile:true } /* placeholder id for demo */
  ]}
];
const CATALOG={}; for(const sec of SECTIONS) for(const it of sec.items){
  CATALOG[it.id] = { id:it.id, name:it.name, studs:it.studs, height:it.height, mask:it.mask||'rect', hollow:!!it.hollow, tile:!!it.tile };
}

/* ===== colors ===== */
const COLOR_SETS = [
  { title:'Plastic (Opaque)', glass:false, items:[
    {name:'White',  hex:0xFFFFFF},
    {name:'Black',  hex:0x05131D},
    {name:'Red',    hex:0xDA0000},
    {name:'Blue',   hex:0x0055BF},
    {name:'Green',  hex:0x237841},
    {name:'Yellow', hex:0xF2CD37},
    {name:'LBG',    hex:0xA0A5A9},
    {name:'DBG',    hex:0x6D6E5C}
  ]},
  { title:'Glass (Transparent)', glass:true, items:[
    {name:'Trans-Clear',  hex:0xFFFFFF},
    {name:'Trans-Blue',   hex:0x3BC5FF},
    {name:'Trans-Red',    hex:0xFF3B3B},
    {name:'Trans-Yellow', hex:0xFFF85A}
  ]}
];
let currentColor = { name:'Blue', hex:0x0055BF, glass:false };

const btnColor = document.getElementById('btnColor');
const menuColor = document.getElementById('menuColor');
const btnColorDot = document.getElementById('btnColorDot');
const btnColorLabel = document.getElementById('btnColorLabel');

btnColor.addEventListener('click', (e)=>{ e.stopPropagation(); menuColor.classList.toggle('show'); });
menuColor.addEventListener('click', (e)=> e.stopPropagation());
menuColor.addEventListener('mousedown', (e)=> e.stopPropagation());

function renderColorMenu(){
  menuColor.innerHTML='';
  COLOR_SETS.forEach((set, idx)=>{
    const wrap=document.createElement('div'); wrap.className='sec';
    const hdr=document.createElement('h4');
    const title=document.createElement('span'); title.textContent=set.title;
    const caret=document.createElement('span'); caret.textContent='▾'; caret.style.opacity='.6';
    hdr.appendChild(title); hdr.appendChild(caret);

    const body=document.createElement('div'); body.className='body';
    set.items.forEach(it=>{
      const b=document.createElement('button'); b.className='item';
      const dot=document.createElement('span'); dot.className='dot'; dot.style.background='#'+it.hex.toString(16).padStart(6,'0');
      b.appendChild(dot); b.appendChild(document.createTextNode(' '+it.name));
      b.addEventListener('click', ()=>{
        currentColor = { name: it.name, hex: it.hex, glass: set.glass };
        btnColorDot.style.background = '#'+it.hex.toString(16).padStart(6,'0');
        btnColorLabel.textContent = it.name + ' · ' + (set.glass? 'Glass':'Plastic');
        if(ghost){
          const id = sourceKey, turns=quarterTurns, pos=ghost.position.clone();
          ghost.traverse(o=>{ if((o.isMesh||o.isInstancedMesh)&&o.material) o.material.dispose?.(); });
          scene.remove(ghost);
          ghost = makePartMesh(id, currentColor, { ghost:true });
          ghost.position.copy(pos);
          ghost.rotation.set(0,(turns&3)*(Math.PI/2),0);
          scene.add(ghost);
        }
      });
      body.appendChild(b);
    });

    body.style.display = idx===0 ? 'grid' : 'none';
    hdr.addEventListener('click', (e)=>{
      e.stopPropagation();
      const open = body.style.display!=='none';
      body.style.display = open ? 'none' : 'grid';
      caret.textContent = open ? '▸' : '▾';
    });

    wrap.appendChild(hdr); wrap.appendChild(body);
    menuColor.appendChild(wrap);
  });
}
renderColorMenu();

/* parts dropdown */
const btnParts = document.getElementById('btnParts');
const menuParts = document.getElementById('menuParts');
btnParts.addEventListener('click', (e)=>{ e.stopPropagation(); menuParts.classList.toggle('show'); });
menuParts.addEventListener('click', (e)=> e.stopPropagation());
menuParts.addEventListener('mousedown', (e)=> e.stopPropagation());

function renderPartsMenu(){
  menuParts.innerHTML='';
  SECTIONS.forEach((sec, idx)=>{
    const wrap=document.createElement('div'); wrap.className='sec';
    const hdr=document.createElement('h4');
    const title=document.createElement('span'); title.textContent=sec.title;
    const caret=document.createElement('span'); caret.textContent='▾'; caret.style.opacity='.6';
    hdr.appendChild(title); hdr.appendChild(caret);
    const body=document.createElement('div'); body.className='body';

    sec.items.forEach(it=>{
      const b=document.createElement('button');
      b.className='item';
      b.innerHTML = it.name + ' <small>' + it.id + '</small>';
      b.addEventListener('click', ()=> startPlacing(it.id));
      body.appendChild(b);
    });

    body.style.display = idx<2 ? 'grid' : 'none';
    hdr.addEventListener('click', (e)=>{
      e.stopPropagation();
      const open = body.style.display!=='none';
      body.style.display = open ? 'none' : 'grid';
      caret.textContent = open ? '▸' : '▾';
    });

    wrap.appendChild(hdr); wrap.appendChild(body);
    menuParts.appendChild(wrap);
  });
}
renderPartsMenu();

/* close menus on outside click */
document.addEventListener('click', (e)=>{
  if (!e.target.closest('.dd')) {
    menuParts.classList.remove('show');
    menuColor.classList.remove('show');
  }
});

/* ===== materials ===== */
function matPlastic(hex, opts={}){
  const m = new THREE.MeshPhysicalMaterial({
    color: new THREE.Color(hex),
    roughness: 0.92, metalness: 0.0,
    clearcoat: 0.0, clearcoatRoughness: 0.25
  });
  if(opts.ghost){ m.transparent=true; m.opacity=0.6; }
  if(opts.hollow && !opts.glass){ m.transparent=true; m.opacity = opts.ghost? 0.5 : 0.42; m.depthWrite=true; }
  return m;
}
function matGlass(hex, opts={}){
  const m = new THREE.MeshPhysicalMaterial({
    color: new THREE.Color(hex),
    metalness: 0.0,
    roughness: opts.ghost ? 0.15 : 0.05,
    ior: 1.45,
    transmission: 1.0,
    thickness: 4.0,
    attenuationColor: new THREE.Color(hex),
    attenuationDistance: 48,
    clearcoat: 0.1,
    clearcoatRoughness: 0.2
  });
  if(opts.ghost){ m.transparent=true; m.opacity=0.6; }
  return m;
}
function makeMaterialFor(part, colorSel, opts={}){
  const base = colorSel?.glass ? matGlass : matPlastic;
  return base(colorSel?.hex ?? 0x0055BF, { ghost: !!opts.ghost, hollow: part.hollow, glass: colorSel?.glass });
}

/* ===== masks & geometry ===== */
function buildMask(sx, sz, mode){
  const mask = Array.from({length:sz}, ()=> Array(sx).fill(true));
  if(mode==='corner'){ // thin L (1-stud legs)
    for(let z=0; z<sz; z++) for(let x=0; x<sx; x++){ mask[z][x] = (x===0 || z===0); }
  }
  else if(mode==='cross' && sx===3 && sz===3){
    for(let z=0; z<3; z++) for(let x=0; x<3; x++){ mask[z][x] = (x===1 || z===1); }
  }
  else if(mode==='cutout_center_2x2' && sx>=4 && sz>=4){
    const cx=Math.floor(sx/2)-1, cz=Math.floor(sz/2)-1;
    for(let z=cz; z<cz+2; z++) for(let x=cx; x<cx+2; x++) mask[z][x]=false;
  }
  else if(mode==='cutout_corner'){ // remove 1×1 at (+x,+z) corner
    mask[sz-1][sx-1] = false;
  }
  else if(mode==='corner_quadrant' && sx===4 && sz===4){ // remove a 2×2 quadrant (4×4 Corner plate)
    for(let z=2; z<4; z++) for(let x=2; x<4; x++) mask[z][x]=false;
  }
  return mask;
}
function makeBodyGeometryRect(sx, sz, h){
  const w = sx*STUD_PITCH, d = sz*STUD_PITCH;
  const radius = Math.min(0.7, Math.min(w,d)*0.06);
  return new RoundedBoxGeometry(w, h, d, 3, radius);
}
function makeBodyGeometryMasked(sx, sz, h, mask){
  const geos=[]; const r = Math.min(0.8, STUD_PITCH*0.28);
  for(let z=0; z<sz; z++) for(let x=0; x<sx; x++){
    if(!mask[z][x]) continue;
    const g=new RoundedBoxGeometry(STUD_PITCH,h,STUD_PITCH,2,r);
    g.translate((x-(sx-1)/2)*STUD_PITCH,0,(z-(sz-1)/2)*STUD_PITCH);
    geos.push(g);
  }
  const merged = BufferGeometryUtils.mergeGeometries(geos,true);
  return merged || new THREE.BoxGeometry(STUD_PITCH,h,STUD_PITCH);
}
function addDomedStuds(body, sx, sz, h, mat, mask){
  if(body.userData?.tile) return;
  const positions=[];
  for(let z=0; z<sz; z++) for(let x=0; x<sx; x++){ if(!mask || mask[z][x]) positions.push([(x-(sx-1)/2)*STUD_PITCH,(h/2),(z-(sz-1)/2)*STUD_PITCH]); }
  if(!positions.length) return;
  const coreGeo=new THREE.CylinderGeometry(STUD_RADIUS*0.96,STUD_RADIUS*0.96,STUD_HEIGHT*0.88,24,1,false);
  const lipGeo=new THREE.TorusGeometry(STUD_RADIUS*0.98,0.18,10,24); lipGeo.rotateX(Math.PI/2);
  const domeGeo=new THREE.SphereGeometry(STUD_RADIUS*0.9,16,12,0,Math.PI*2,0,Math.PI/2);
  const core=new THREE.InstancedMesh(coreGeo,mat,positions.length);
  const lip=new THREE.InstancedMesh(lipGeo,mat,positions.length);
  const dome=new THREE.InstancedMesh(domeGeo,mat,positions.length);
  const m=new THREE.Matrix4();
  for(let i=0;i<positions.length;i++){
    const [x,y,z]=positions[i];
    m.identity().setPosition(x,y+STUD_HEIGHT/2,z); core.setMatrixAt(i,m);
    m.identity().setPosition(x,y+STUD_HEIGHT-0.05,z); lip.setMatrixAt(i,m);
    m.identity().setPosition(x,y+STUD_HEIGHT,z); dome.setMatrixAt(i,m);
  }
  core.instanceMatrix.needsUpdate = lip.instanceMatrix.needsUpdate = dome.instanceMatrix.needsUpdate = true;
  body.add(core,lip,dome);
}

/* ===== part factory ===== */
function makePartMesh(partId, colorSel = currentColor, opts = {}) {
  const p = CATALOG[partId]; if (!p) return new THREE.Mesh();
  const [sx,sz]=p.studs, h=p.height;
  const mask = buildMask(sx, sz, p.mask);
  const colObj = (colorSel && typeof colorSel === 'object' && 'hex' in colorSel)
    ? colorSel
    : { hex: (typeof colorSel === 'number' ? colorSel : currentColor.hex), glass: !!currentColor.glass };
  const mat = makeMaterialFor(p, colObj, { ghost: !!opts.ghost });
  const geo = (p.mask!=='rect') ? makeBodyGeometryMasked(sx,sz,h,mask) : makeBodyGeometryRect(sx,sz,h);
  const body = new THREE.Mesh(geo, mat);
  body.userData = {
    id: p.id,
    studsX:sx, studsZ:sz,
    height:h,
    maskType:p.mask,
    tile:p.tile===true,
    hollow:p.hollow===true,
    colorHex: colObj.hex,
    glass: !!colObj.glass
  };
  if (!p.tile) addDomedStuds(body, sx, sz, h, mat, mask);
  body.geometry.computeBoundingBox();
  return body;
}

/* ===== selection (outline) ===== */
let selected=null, outline=null;
const outlineMat = new THREE.LineBasicMaterial({ color: 0x2563EB });
function clearSelection(){
  if(outline){ scene.remove(outline); outline.geometry.dispose(); outline=null; }
  selected=null;
}
function selectMesh(m){
  clearSelection(); selected=m;
  const edges = new THREE.EdgesGeometry(m.geometry, 45);
  outline = new THREE.LineSegments(edges, outlineMat);
  outline.position.copy(m.position); outline.rotation.copy(m.rotation); outline.scale.copy(m.scale).multiplyScalar(1.001);
  outline.renderOrder=9999; scene.add(outline);
}
function syncOutline(){ if(!selected||!outline) return; outline.position.copy(selected.position); outline.rotation.copy(selected.rotation); }

/* ===== placement (stud-locked) ===== */
const ray=new THREE.Raycaster(); const mouse=new THREE.Vector2();
let ghost=null, sourceKey=null, quarterTurns=0;
const hint=document.getElementById('hint');
const snapEdge = v => Math.round(v / STUD_PITCH) * STUD_PITCH;
function orientedStuds(turns, sx, sz){ return (turns & 1) ? { sx: sz, sz: sx } : { sx, sz }; }

function bodyBoxWorld(mesh){
  mesh.updateWorldMatrix(true,false);
  const bb = mesh.geometry.boundingBox || (mesh.geometry.computeBoundingBox(), mesh.geometry.boundingBox);
  return bb.clone().applyMatrix4(mesh.matrixWorld);
}
function collides(mesh){
  const a=bodyBoxWorld(mesh);
  const half=(BASE_STUDS*STUD_PITCH)/2;
  if(a.min.x<-half || a.max.x>half || a.min.z<-half || a.max.z>half || a.min.y<0) return true;
  for(const c of modelRoot.children){
    if(!c.isMesh) continue;
    const b=bodyBoxWorld(c);
    if(a.max.x>b.min.x && a.min.x<b.max.x &&
       a.max.y>b.min.y && a.min.y<b.max.y &&
       a.max.z>b.min.z && a.min.z<b.max.z) return true;
  }
  return false;
}
function setGhostOK(ok){
  if(!ghost) return;
  ghost.traverse(o=>{
    if((o.isMesh || o.isInstancedMesh) && o.material){
      const m=o.material;
      if(ok){
        if(currentColor.glass){ m.transmission=1.0; m.ior=1.45; m.roughness=0.15; m.opacity=0.6; }
        else { m.transmission=0.0; m.roughness=0.6; m.opacity=0.6; }
        m.color.setHex(currentColor.hex);
      }else{
        m.color.setHex(0xC62828); m.transmission=0.0; m.opacity=0.55;
      }
      m.needsUpdate=true;
    }
  });
}
function startPlacing(key){
  const p=CATALOG[key]; if(!p) return;
  if(ghost){ scene.remove(ghost); ghost=null; }
  sourceKey=key;
  ghost=makePartMesh(key, currentColor, { ghost:true });
  scene.add(ghost); quarterTurns=0; hint.style.display='block'; clearSelection();
}
function cancelPlacing(){ if(ghost){ scene.remove(ghost); ghost=null; } sourceKey=null; quarterTurns=0; hint.style.display='none'; }

window.addEventListener('mousemove',(e)=>{
  const rect=renderer.domElement.getBoundingClientRect();
  mouse.x=((e.clientX-rect.left)/rect.width)*2-1; mouse.y=-((e.clientY-rect.top)/rect.height)*2+1;
  ray.setFromCamera(mouse,camera);
  if(!ghost) return;

  const baseSX = ghost.userData.studsX, baseSZ = ghost.userData.studsZ, h=ghost.userData.height;
  const { sx: oSX, sz: oSZ } = orientedStuds(quarterTurns, baseSX, baseSZ);
  const halfX = (oSX * STUD_PITCH)/2;
  const halfZ = (oSZ * STUD_PITCH)/2;

  let cx=0, cz=0, cy=0;

  const hits=ray.intersectObjects(modelRoot.children,true);
  if(hits.length){
    let m = hits[0].object; while(m && (!m.isMesh || !m.userData?.height)) m = m.parent;
    if(m){
      const p = hits[0].point;
      cx = snapEdge(p.x - halfX) + halfX;
      cz = snapEdge(p.z - halfZ) + halfZ;
      cy = bodyBoxWorld(m).max.y + h/2 + EPS;
    }
  }
  if(cy===0){
    const g=ray.intersectObject(pickPlane,false)[0];
    if(g){
      cx = snapEdge(g.point.x - halfX) + halfX;
      cz = snapEdge(g.point.z - halfZ) + halfZ;
      cy = PLATE_HEIGHT + h/2;
    } else { return; }
  }

  ghost.position.set(cx,cy,cz);
  ghost.rotation.set(0,(quarterTurns&3)*(Math.PI/2),0);
  setGhostOK(!collides(ghost));
});

window.addEventListener('keydown',(e)=>{
  if(e.key.toLowerCase()==='r' && ghost){ quarterTurns=(quarterTurns+1)&3; }
  if(e.key==='Escape'){ menuParts.classList.remove('show'); menuColor.classList.remove('show'); cancelPlacing(); }
  if((e.key==='Delete'||e.key==='Backspace') && selected){ modelRoot.remove(selected); clearSelection(); }
});

window.addEventListener('mousedown',(e)=>{
  if(ghost && e.button===0){
    if(!collides(ghost)){
      const real=makePartMesh(sourceKey, currentColor);
      real.position.copy(ghost.position);
      real.rotation.copy(ghost.rotation);
      modelRoot.add(real);
    }
    return;
  }
  if(!ghost && e.button===0){
    const rect=renderer.domElement.getBoundingClientRect();
    const x=((e.clientX-rect.left)/rect.width)*2-1, y=-((e.clientY-rect.top)/rect.height)*2+1;
    const rc=new THREE.Raycaster(); rc.setFromCamera({x,y}, camera);
    const hits=rc.intersectObjects(modelRoot.children,true);
    if(hits.length){
      let m=hits[0].object; while(m && !m.userData?.id) m=m.parent;
      if(m) selectMesh(m);
    } else clearSelection();
  }
});

/* ===== Save/Load ===== */
function downloadJSON(filename, obj) {
  const blob = new Blob([JSON.stringify(obj, null, 2)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
}
function snapOf(mesh) {
  return {
    id: mesh.userData.id,
    position: mesh.position.toArray(),
    rotation: [mesh.rotation.x, mesh.rotation.y, mesh.rotation.z],
    colorHex: mesh.userData.colorHex ?? (mesh.material?.color?.getHex?.() ?? null),
    glass: !!mesh.userData.glass
  };
}
function serializeBuild() {
  const parts = modelRoot.children
    .filter(o => o.isMesh && o.userData?.id)
    .map(snapOf);
  return { parts };
}
function loadBuild(data) {
  [...modelRoot.children].forEach(c => modelRoot.remove(c));
  clearSelection();
  for (const p of (data?.parts || [])) {
    const colorObj = (typeof p.colorHex === 'number')
      ? { hex: p.colorHex, glass: !!p.glass }
      : (typeof p.color === 'number' ? { hex: p.color, glass: !!p.glass } : currentColor);
    const m = makePartMesh(p.id, colorObj);
    if (Array.isArray(p.position)) m.position.fromArray(p.position);
    if (Array.isArray(p.rotation)) m.rotation.set(...p.rotation);
    modelRoot.add(m);
  }
}
document.getElementById('btnSave').addEventListener('click', () => {
  const data = serializeBuild();
  downloadJSON('build.json', data);
});
const fileIn = document.getElementById('fileIn');
document.getElementById('btnLoad').addEventListener('click', () => fileIn.click());
fileIn.addEventListener('change', async () => {
  const f = fileIn.files?.[0];
  if (!f) return;
  try {
    const json = JSON.parse(await f.text());
    loadBuild(json);
  } catch {
    alert('Invalid JSON file');
  } finally {
    fileIn.value = '';
  }
});

/* ===== loop ===== */
function resize(){ const w=renderer.domElement.clientWidth, h=renderer.domElement.clientHeight; renderer.setSize(w,h,false); camera.aspect=w/h; camera.updateProjectionMatrix(); syncOutline(); }
renderer.setAnimationLoop(()=>{ controls.update(); resize(); renderer.render(scene,camera); });
</script>
</body>
</html>
