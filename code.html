<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>LEGO 3D — Stud-Locked (with Tiles)</title>
<style>
  :root{ --bg:#f5f7fb; --fg:#0b1220; --card:#fff; --line:#e5e7eb; }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  #app{height:100%;display:grid;grid-template-columns:260px 1fr;grid-template-rows:50px 1fr;grid-template-areas:"topbar topbar" "sidebar main"}
  header{grid-area:topbar;display:flex;gap:8px;align-items:center;padding:8px 12px;background:#fff;box-shadow:0 2px 12px rgba(0,0,0,.06); position:relative}
  header .grow{flex:1}
  .btn{border:0;border-radius:10px;background:#0b1220;color:#fff;padding:6px 10px;font-weight:600;cursor:pointer}
  .dd-wrap{position:relative;display:inline-block}
  .menu{position:absolute;top:100%;right:0;background:#fff;border:1px solid var(--line);border-radius:12px;box-shadow:0 12px 28px rgba(0,0,0,.14);padding:8px;display:none;z-index:20;min-width:320px;max-height:70vh;overflow:auto}
  .menu.show{display:block}
  .sec{border:1px solid var(--line);border-radius:10px;margin:8px 0;background:#fafbfc}
  .sec h4{margin:0;padding:10px 12px;font-size:13px;background:#f1f5f9;border-bottom:1px solid var(--line);display:flex;justify-content:space-between;align-items:center;cursor:pointer}
  .sec .body{padding:8px;display:grid;grid-template-columns:1fr 1fr;gap:6px}
  .item{display:block;text-align:left;border:1px solid var(--line);background:#fff;padding:8px 10px;border-radius:8px;cursor:pointer;font-size:13px}
  .item small{color:#6b7280}
  .item:hover{background:#f8fafc}
  #sidebar{grid-area:sidebar;padding:12px;overflow:auto;background:#eef2f7;border-right:1px solid var(--line)}
  .card{background:var(--card);border-radius:12px;padding:10px;box-shadow:0 6px 18px rgba(0,0,0,.07)}
  .card + .card{margin-top:12px}
  #main{grid-area:main;position:relative}
  #c{width:100%;height:100%;display:block}
  .hint{position:absolute;left:12px;top:12px;background:rgba(0,0,0,.7);color:#fff;padding:6px 10px;border-radius:8px;font-size:12px;display:none;z-index:2}
  .dot{width:16px;height:16px;border-radius:50%;border:1px solid #cbd5e1}
  .kbd{background:#0b1220;color:#fff;border-radius:6px;padding:1px 6px;font-size:11px}
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>
</head>
<body>
<div id="app">
  <header>
    <strong>LEGO 3D — Stud-Locked</strong>
    <div class="grow"></div>

    <!-- Color dropdown -->
    <div class="dd-wrap">
      <button id="btnColor" class="btn" title="Choose material & color">
        <span id="btnColorDot" class="dot" style="display:inline-block;vertical-align:middle;background:#0055BF"></span>
        <span id="btnColorLabel">Blue · Plastic</span> ▾
      </button>
      <div id="menuColor" class="menu" role="menu" aria-label="Choose a color"></div>
    </div>

    <!-- Parts dropdown -->
    <div class="dd-wrap">
      <button id="btnParts" class="btn" title="Choose part">Parts ▾</button>
      <div id="menuParts" class="menu" role="menu" aria-label="Choose a part"></div>
    </div>
  </header>

  <aside id="sidebar">
    <div class="card" style="font-size:12px;color:#6b7280;line-height:1.5">
      • L-drag orbit · R-drag pan · wheel zoom<br/>
      • Pick a <b>Color</b> then <b>Part</b><br/>
      • <b class="kbd">R</b> rotate ghost · click to drop (keeps placing) · <b class="kbd">Esc</b> cancel<br/>
      • Click part to select (blue outline) · <b class="kbd">Delete</b> removes<br/>
      • Stud grid enforced — no half offsets
    </div>
  </aside>

  <main id="main">
    <canvas id="c"></canvas>
    <div id="hint" class="hint">Placing… R rotates · click to drop · Esc cancels</div>
  </main>
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';
import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

/* ===== constants ===== */
const STUD_PITCH=8, PLATE_HEIGHT=3.2, BRICK_HEIGHT=9.6, BASE_STUDS=48;
const STUD_DIAMETER=4.8, STUD_RADIUS=STUD_DIAMETER/2, STUD_HEIGHT=1;
const EPS = 0.001;

/* ===== renderer & scene ===== */
const renderer=new THREE.WebGLRenderer({canvas:document.getElementById('c'),antialias:true});
renderer.setPixelRatio(devicePixelRatio);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.physicallyCorrectLights = true;

const scene=new THREE.Scene(); scene.background=new THREE.Color(0xf5f7fb);
const camera=new THREE.PerspectiveCamera(45,2,0.1,6000); camera.position.set(230,230,260);
const controls=new OrbitControls(camera,renderer.domElement);
controls.enableDamping=true; controls.dampingFactor=.07;

scene.add(new THREE.HemisphereLight(0xffffff,0xb0b8c2,0.9));
const sun=new THREE.DirectionalLight(0xffffff,1.0); sun.position.set(300,420,250); scene.add(sun);

/* simple bright room for glass refraction */
(function addRoom(){
  const room = new THREE.Mesh(
    new THREE.BoxGeometry(2000,1200,2000),
    new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.BackSide })
  );
  room.position.y = 300;
  scene.add(room);
})();

/* ===== baseplate + grid ===== */
const baseplate=new THREE.Group(); scene.add(baseplate);
const plate=new THREE.Mesh(
  new THREE.BoxGeometry(BASE_STUDS*STUD_PITCH, PLATE_HEIGHT, BASE_STUDS*STUD_PITCH),
  new THREE.MeshStandardMaterial({color:0x9ecae1,roughness:0.95,metalness:0})
);
plate.position.y=PLATE_HEIGHT/2; baseplate.add(plate);
const grid=new THREE.GridHelper(BASE_STUDS*STUD_PITCH,BASE_STUDS,0x8da0b8,0xe3e7ee);
grid.rotation.x=Math.PI/2; baseplate.add(grid);

const pickPlane=new THREE.Mesh(new THREE.PlaneGeometry(4000,4000),new THREE.MeshBasicMaterial({visible:false}));
pickPlane.rotateX(-Math.PI/2); pickPlane.position.y=PLATE_HEIGHT; scene.add(pickPlane);
const modelRoot=new THREE.Group(); scene.add(modelRoot);

/* ===== parts catalog (sections) ===== */
const SECTIONS = [
  { title: 'Brick › 1× Brick', items: [
    { id:'3005', name:'1×1', studs:[1,1], height:BRICK_HEIGHT },
    { id:'3004', name:'1×2', studs:[1,2], height:BRICK_HEIGHT },
    { id:'3622', name:'1×3', studs:[1,3], height:BRICK_HEIGHT },
    { id:'3010', name:'1×4', studs:[1,4], height:BRICK_HEIGHT },
    { id:'3009', name:'1×6', studs:[1,6], height:BRICK_HEIGHT },
    { id:'3008', name:'1×8', studs:[1,8], height:BRICK_HEIGHT },
    { id:'6111', name:'1×10', studs:[1,10], height:BRICK_HEIGHT },
    { id:'6112', name:'1×12', studs:[1,12], height:BRICK_HEIGHT },
    { id:'2465', name:'1×16', studs:[1,16], height:BRICK_HEIGHT },
    { id:'2357', name:'2×2 Corner', studs:[2,2], height:BRICK_HEIGHT, mask:'corner' }
  ]},
  { title: 'Brick › 2× Brick', items: [
    { id:'3003', name:'2×2', studs:[2,2], height:BRICK_HEIGHT },
    { id:'3002', name:'2×3', studs:[2,3], height:BRICK_HEIGHT },
    { id:'3001', name:'2×4', studs:[2,4], height:BRICK_HEIGHT },
    { id:'2456', name:'2×6', studs:[2,6], height:BRICK_HEIGHT },
    { id:'3007', name:'2×8', studs:[2,8], height:BRICK_HEIGHT },
    { id:'3006', name:'2×10', studs:[2,10], height:BRICK_HEIGHT }
  ]},
  { title: 'Brick › Tall Brick', items: [
    { id:'14716', name:'1×1×3', studs:[1,1], height:BRICK_HEIGHT*3 },
    { id:'2453',  name:'1×1×5', studs:[1,1], height:BRICK_HEIGHT*5 },
    { id:'3245',  name:'1×2×2', studs:[1,2], height:BRICK_HEIGHT*2 },
    { id:'22886', name:'1×2×3', studs:[1,2], height:BRICK_HEIGHT*3 },
    { id:'2454',  name:'1×2×5', studs:[1,2], height:BRICK_HEIGHT*5 },
    { id:'30145', name:'2×2×3', studs:[2,2], height:BRICK_HEIGHT*3 },
    { id:'49311', name:'1×4×3', studs:[1,4], height:BRICK_HEIGHT*3 }
  ]},
  { title: 'Brick › Hollow Brick (see-through)', items: [
    { id:'3065',  name:'1×2 Hollow',   studs:[1,2], height:BRICK_HEIGHT,  hollow:true },
    { id:'46212', name:'1×2×5 Hollow', studs:[1,2], height:BRICK_HEIGHT*5, hollow:true },
    { id:'3066',  name:'1×4 Hollow',   studs:[1,4], height:BRICK_HEIGHT,  hollow:true }
  ]},
  { title: 'Plate › 1× Plate', items: [
    { id:'3024', name:'1×1', studs:[1,1], height:PLATE_HEIGHT },
    { id:'3023', name:'1×2', studs:[1,2], height:PLATE_HEIGHT },
    { id:'3623', name:'1×3', studs:[1,3], height:PLATE_HEIGHT },
    { id:'3710', name:'1×4', studs:[1,4], height:PLATE_HEIGHT },
    { id:'78329',name:'1×5', studs:[1,5], height:PLATE_HEIGHT },
    { id:'3666', name:'1×6', studs:[1,6], height:PLATE_HEIGHT },
    { id:'3460', name:'1×8', studs:[1,8], height:PLATE_HEIGHT },
    { id:'4477', name:'1×10', studs:[1,10], height:PLATE_HEIGHT },
    { id:'60479',name:'1×12', studs:[1,12], height:PLATE_HEIGHT },
    { id:'2420', name:'2×2 Corner', studs:[2,2], height:PLATE_HEIGHT, mask:'corner' },
    { id:'77844',name:'3×3 Corner', studs:[3,3], height:PLATE_HEIGHT, mask:'corner' },
    { id:'15397',name:'3×3 Cross',  studs:[3,3], height:PLATE_HEIGHT, mask:'cross' },
    { id:'73831',name:'2×3 w/ Cutout', studs:[2,3], height:PLATE_HEIGHT, mask:'cutout_corner' },
    { id:'64799',name:'4×4 w/ Cutout', studs:[4,4], height:PLATE_HEIGHT, mask:'cutout_center_2x2' }
  ]},
  { title: 'Plate › 2× Plate', items: [
    { id:'3022', name:'2×2', studs:[2,2], height:PLATE_HEIGHT },
    { id:'3021', name:'2×3', studs:[2,3], height:PLATE_HEIGHT },
    { id:'3020', name:'2×4', studs:[2,4], height:PLATE_HEIGHT },
    { id:'3795', name:'2×6', studs:[2,6], height:PLATE_HEIGHT },
    { id:'3034', name:'2×8', studs:[2,8], height:PLATE_HEIGHT },
    { id:'3832', name:'2×10', studs:[2,10], height:PLATE_HEIGHT },
    { id:'2445', name:'2×12', studs:[2,12], height:PLATE_HEIGHT },
    { id:'91988',name:'2×14', studs:[2,14], height:PLATE_HEIGHT },
    { id:'4282', name:'2×16', studs:[2,16], height:PLATE_HEIGHT },
    { id:'2639', name:'4×4 Corner', studs:[4,4], height:PLATE_HEIGHT, mask:'corner' }
  ]},
  { title: 'Plate › Large Plate', items: [
    { id:'11212',name:'3×3', studs:[3,3], height:PLATE_HEIGHT },
    { id:'3031', name:'4×4', studs:[4,4], height:PLATE_HEIGHT },
    { id:'3032', name:'4×6', studs:[4,6], height:PLATE_HEIGHT },
    { id:'3035', name:'4×8', studs:[4,8], height:PLATE_HEIGHT },
    { id:'3030', name:'4×10', studs:[4,10], height:PLATE_HEIGHT },
    { id:'3029', name:'4×12', studs:[4,12], height:PLATE_HEIGHT },
    { id:'3958', name:'6×6', studs:[6,6], height:PLATE_HEIGHT },
    { id:'3036', name:'6×8', studs:[6,8], height:PLATE_HEIGHT },
    { id:'3033', name:'6×10', studs:[6,10], height:PLATE_HEIGHT },
    { id:'3028', name:'6×12', studs:[6,12], height:PLATE_HEIGHT },
    { id:'3456', name:'6×14', studs:[6,14], height:PLATE_HEIGHT },
    { id:'3027', name:'6×16', studs:[6,16], height:PLATE_HEIGHT },
    { id:'41539',name:'8×8', studs:[8,8], height:PLATE_HEIGHT },
    { id:'92438',name:'8×16', studs:[8,16], height:PLATE_HEIGHT },
    { id:'plate_16x16', name:'16×16', studs:[16,16], height:PLATE_HEIGHT }
  ]},
  /* ==== NEW: Tiles (no studs) ==== */
  { title: 'Tile › 1× Tile', items: [
    { id:'3070',  name:'1×1 Tile', studs:[1,1], height:PLATE_HEIGHT, tile:true },
    { id:'3069',  name:'1×2 Tile', studs:[1,2], height:PLATE_HEIGHT, tile:true },
    { id:'63864', name:'1×3 Tile', studs:[1,3], height:PLATE_HEIGHT, tile:true },
    { id:'2431',  name:'1×4 Tile', studs:[1,4], height:PLATE_HEIGHT, tile:true },
    { id:'6636',  name:'1×6 Tile', studs:[1,6], height:PLATE_HEIGHT, tile:true },
    { id:'4162',  name:'1×8 Tile', studs:[1,8], height:PLATE_HEIGHT, tile:true },
    { id:'14719', name:'2×2 Tile, Corner', studs:[2,2], height:PLATE_HEIGHT, tile:true, mask:'corner' }
  ]},
  { title: 'Tile › 2× Tile', items: [
    { id:'3068',  name:'2×2 Tile', studs:[2,2], height:PLATE_HEIGHT, tile:true },
    { id:'26603', name:'2×3 Tile', studs:[2,3], height:PLATE_HEIGHT, tile:true },
    { id:'87079', name:'2×4 Tile', studs:[2,4], height:PLATE_HEIGHT, tile:true },
    { id:'69729', name:'2×6 Tile', studs:[2,6], height:PLATE_HEIGHT, tile:true }
  ]},
  { title: 'Tile › Large Tile', items: [
    { id:'1751N', name:'4×4 Tile', studs:[4,4], height:PLATE_HEIGHT, tile:true },
    { id:'10202', name:'6×6 Tile', studs:[6,6], height:PLATE_HEIGHT, tile:true },
    { id:'tile_8x16', name:'8×16 Tile', studs:[8,16], height:PLATE_HEIGHT, tile:true }
  ]}
];

const CATALOG={};
for(const sec of SECTIONS) for(const it of sec.items){
  CATALOG[it.id] = {
    id:it.id, name:it.name, studs:it.studs, height:it.height,
    mask:it.mask||'rect', hollow:!!it.hollow, tile:!!it.tile
  };
}

/* ===== colors dropdown ===== */
const COLOR_SETS = [
  { title:'Plastic (Opaque)', glass:false, items:[
    {name:'White',  hex:0xFFFFFF},
    {name:'Black',  hex:0x05131D},
    {name:'Red',    hex:0xDA0000},
    {name:'Blue',   hex:0x0055BF},
    {name:'Green',  hex:0x237841},
    {name:'Yellow', hex:0xF2CD37},
    {name:'LBG',    hex:0xA0A5A9},
    {name:'DBG',    hex:0x6D6E5C},
    {name:'Tan',    hex:0xD2B48C}
  ]},
  { title:'Glass (Transparent)', glass:true, items:[
    {name:'Trans-Clear',  hex:0xFFFFFF},
    {name:'Trans-Red',    hex:0xFF3B3B},
    {name:'Trans-Green',  hex:0x37FF8B},
    {name:'Trans-Blue',   hex:0x3BC5FF},
    {name:'Trans-Yellow', hex:0xFFF85A}
  ]}
];

let currentColor = { name:'Blue', hex:0x0055BF, glass:false };
const btnColor = document.getElementById('btnColor');
const menuColor = document.getElementById('menuColor');
const btnColorDot = document.getElementById('btnColorDot');
const btnColorLabel = document.getElementById('btnColorLabel');

btnColor.addEventListener('click', (e)=>{ e.stopPropagation(); menuColor.classList.toggle('show'); });
menuColor.addEventListener('click', (e)=> e.stopPropagation());
menuColor.addEventListener('mousedown', (e)=> e.stopPropagation());

function renderColorMenu(){
  menuColor.innerHTML='';
  COLOR_SETS.forEach((set, idx)=>{
    const wrap=document.createElement('div'); wrap.className='sec';
    const hdr=document.createElement('h4');
    const title=document.createElement('span'); title.textContent=set.title;
    const caret=document.createElement('span'); caret.textContent='▾'; caret.style.opacity='.6';
    hdr.appendChild(title); hdr.appendChild(caret);

    const body=document.createElement('div'); body.className='body';
    set.items.forEach(it=>{
      const b=document.createElement('button'); b.className='item';
      const sw=document.createElement('span');
      const dot=document.createElement('span'); dot.className='dot'; dot.style.background='#'+it.hex.toString(16).padStart(6,'0');
      const label=document.createElement('span'); label.textContent=it.name;
      sw.style.display='inline-flex'; sw.style.alignItems='center'; sw.style.gap='8px';
      sw.appendChild(dot); sw.appendChild(label);
      b.appendChild(sw);
      b.addEventListener('click', ()=>{
        currentColor = { name: it.name, hex: it.hex, glass: set.glass };
        btnColorDot.style.background = '#'+it.hex.toString(16).padStart(6,'0');
        btnColorLabel.textContent = `${it.name} · ${set.glass? 'Glass':'Plastic'}`;
        if(ghost){
          const id = sourceKey, turns=quarterTurns, pos=ghost.position.clone();
          ghost.traverse(o=>{ if((o.isMesh||o.isInstancedMesh)&&o.material) o.material.dispose?.(); });
          scene.remove(ghost);
          ghost = makePartMesh(id, currentColor, { ghost:true });
          ghost.position.copy(pos);
          ghost.rotation.set(0,(turns&3)*(Math.PI/2),0);
          scene.add(ghost);
        }
      });
      body.appendChild(b);
    });

    body.style.display = idx===0 ? 'grid' : 'none';
    hdr.addEventListener('click', (e)=>{
      e.stopPropagation();
      const open = body.style.display!=='none';
      body.style.display = open ? 'none' : 'grid';
      caret.textContent = open ? '▸' : '▾';
    });

    wrap.appendChild(hdr); wrap.appendChild(body);
    menuColor.appendChild(wrap);
  });
}
renderColorMenu();

/* ===== parts dropdown ===== */
const btnParts = document.getElementById('btnParts');
const menuParts = document.getElementById('menuParts');
btnParts.addEventListener('click', (e)=>{ e.stopPropagation(); menuParts.classList.toggle('show'); });
menuParts.addEventListener('click', (e)=> e.stopPropagation());
menuParts.addEventListener('mousedown', (e)=> e.stopPropagation());

function renderPartsMenu(){
  menuParts.innerHTML='';
  SECTIONS.forEach((sec, idx)=>{
    const wrap=document.createElement('div'); wrap.className='sec';
    const hdr=document.createElement('h4');
    const title=document.createElement('span'); title.textContent=sec.title;
    const caret=document.createElement('span'); caret.textContent='▾'; caret.style.opacity='.6';
    hdr.appendChild(title); hdr.appendChild(caret);
    const body=document.createElement('div'); body.className='body';

    sec.items.forEach(it=>{
      const b=document.createElement('button');
      b.className='item';
      b.innerHTML=`${it.name} <small>${it.id}</small>`;
      b.addEventListener('click', ()=>{ startPlacing(it.id); });
      body.appendChild(b);
    });

    body.style.display = idx<2 ? 'grid' : 'none';
    hdr.addEventListener('click', (e)=>{
      e.stopPropagation();
      const open = body.style.display!=='none';
      body.style.display = open ? 'none' : 'grid';
      caret.textContent = open ? '▸' : '▾';
    });

    wrap.appendChild(hdr); wrap.appendChild(body);
    menuParts.appendChild(wrap);
  });
}
renderPartsMenu();

/* Close menus only when clicking OUTSIDE any dropdown */
document.addEventListener('click', (e)=>{
  if (!e.target.closest('.dd-wrap')) {
    menuParts.classList.remove('show');
    menuColor.classList.remove('show');
  }
});

/* ===== materials ===== */
function matPlastic(hex, opts={}){
  const m = new THREE.MeshPhysicalMaterial({
    color: new THREE.Color(hex),
    roughness: 0.92, metalness: 0.0,
    clearcoat: 0.0, clearcoatRoughness: 0.25,
  });
  if(opts.ghost){ m.transparent=true; m.opacity=0.6; }
  if(opts.hollow && !opts.glass){ m.transparent=true; m.opacity = opts.ghost? 0.5 : 0.42; m.depthWrite=true; }
  return m;
}
function matGlass(hex, opts={}){
  const m = new THREE.MeshPhysicalMaterial({
    color: new THREE.Color(hex),
    metalness: 0.0,
    roughness: opts.ghost ? 0.15 : 0.05,
    ior: 1.45,
    transmission: 1.0,
    thickness: 4.0,
    attenuationColor: new THREE.Color(hex),
    attenuationDistance: 48,
    clearcoat: 0.1,
    clearcoatRoughness: 0.2
  });
  if(opts.ghost){ m.transparent=true; m.opacity=0.6; }
  return m;
}
function makeMaterialFor(part, colorSel, opts={}){
  const base = colorSel?.glass ? matGlass : matPlastic;
  return base(colorSel?.hex ?? 0x0055BF, { ghost: !!opts.ghost, hollow: part.hollow, glass: colorSel?.glass });
}

/* ===== masks & geometry ===== */
function buildMask(sx, sz, mode){
  const mask = Array.from({length:sz}, ()=> Array(sx).fill(true));
  if(mode==='corner'){
    for(let z=0; z<sz; z++) for(let x=0; x<sx; x++){ mask[z][x] = (x===0 || z===0); }
  }else if(mode==='cross' && sx===3 && sz===3){
    for(let z=0; z<3; z++) for(let x=0; x<3; x++){ mask[z][x] = (x===1 || z===1); }
  }else if(mode==='cutout_center_2x2' && sx===4 && sz===4){
    for(let z=1; z<=2; z++) for(let x=1; x<=2; x++){ mask[z][x] = false; }
  }else if(mode==='cutout_corner'){
    mask[sz-1][sx-1] = false; // remove one corner cell (L shape)
  }
  return mask;
}
function makeBodyGeometryRect(sx, sz, h){
  const w = sx*STUD_PITCH, d = sz*STUD_PITCH;
  const radius = Math.min(0.7, Math.min(w,d)*0.06);
  return new RoundedBoxGeometry(w, h, d, 3, radius);
}
function makeBodyGeometryMasked(sx, sz, h, mask){
  const geos=[]; const r = Math.min(0.8, STUD_PITCH*0.28);
  for(let z=0; z<sz; z++) for(let x=0; x<sx; x++){
    if(!mask[z][x]) continue;
    const g=new RoundedBoxGeometry(STUD_PITCH,h,STUD_PITCH,2,r);
    g.translate((x-(sx-1)/2)*STUD_PITCH,0,(z-(sz-1)/2)*STUD_PITCH);
    geos.push(g);
  }
  const merged = BufferGeometryUtils.mergeGeometries(geos,true);
  return merged || new THREE.BoxGeometry(STUD_PITCH,h,STUD_PITCH);
}
function addDomedStuds(body, sx, sz, h, mat, mask){
  const positions=[];
  for(let z=0; z<sz; z++) for(let x=0; x<sx; x++){ if(!mask || mask[z][x]) positions.push([(x-(sx-1)/2)*STUD_PITCH,(h/2),(z-(sz-1)/2)*STUD_PITCH]); }
  if(!positions.length) return;
  const coreGeo=new THREE.CylinderGeometry(STUD_RADIUS*0.96,STUD_RADIUS*0.96,STUD_HEIGHT*0.88,24,1,false);
  const lipGeo=new THREE.TorusGeometry(STUD_RADIUS*0.98,0.18,10,24); lipGeo.rotateX(Math.PI/2);
  const domeGeo=new THREE.SphereGeometry(STUD_RADIUS*0.9,16,12,0,Math.PI*2,0,Math.PI/2);
  const core=new THREE.InstancedMesh(coreGeo,mat,positions.length);
  const lip=new THREE.InstancedMesh(lipGeo,mat,positions.length);
  const dome=new THREE.InstancedMesh(domeGeo,mat,positions.length);
  const m=new THREE.Matrix4();
  for(let i=0;i<positions.length;i++){
    const [x,y,z]=positions[i];
    m.identity().setPosition(x,y+STUD_HEIGHT/2,z); core.setMatrixAt(i,m);
    m.identity().setPosition(x,y+STUD_HEIGHT-0.05,z); lip.setMatrixAt(i,m);
    m.identity().setPosition(x,y+STUD_HEIGHT,z); dome.setMatrixAt(i,m);
  }
  core.instanceMatrix.needsUpdate = lip.instanceMatrix.needsUpdate = dome.instanceMatrix.needsUpdate = true;
  body.add(core,lip,dome);
}

/* ===== part factory ===== */
function makePartMesh(partId, colorSel, opts={}){
  const p = CATALOG[partId]; if(!p) return new THREE.Mesh();
  const [sx,sz]=p.studs, h=p.height;
  const mask = buildMask(sx, sz, p.mask);
  const mat = makeMaterialFor(p, currentColor, { ghost: !!opts.ghost });
  const geo = (p.mask!=='rect') ? makeBodyGeometryMasked(sx,sz,h,mask) : makeBodyGeometryRect(sx,sz,h);
  const body = new THREE.Mesh(geo, mat);
  body.userData = { id: p.id, studsX:sx, studsZ:sz, height:h, maskType:p.mask, tile:p.tile===true };
  if (!p.tile) addDomedStuds(body, sx, sz, h, mat, mask);  // tiles: no studs
  body.geometry.computeBoundingBox();
  return body;
}

/* ===== selection (simple outline) ===== */
let selected=null, outline=null;
const outlineMat = new THREE.LineBasicMaterial({ color: 0x2563EB });
function clearSelection(){
  if(outline){ scene.remove(outline); outline.geometry.dispose(); outline=null; }
  selected=null;
}
function selectMesh(m){
  clearSelection(); selected=m;
  const edges = new THREE.EdgesGeometry(m.geometry, 45);
  outline = new THREE.LineSegments(edges, outlineMat);
  outline.position.copy(m.position); outline.rotation.copy(m.rotation); outline.scale.copy(m.scale).multiplyScalar(1.001);
  outline.renderOrder=9999; scene.add(outline);
}
function syncOutline(){ if(!selected||!outline) return; outline.position.copy(selected.position); outline.rotation.copy(selected.rotation); }

/* ===== placement: stud-locked ===== */
const ray=new THREE.Raycaster(); const mouse=new THREE.Vector2();
let ghost=null, sourceKey=null, quarterTurns=0;
const hint=document.getElementById('hint');

const STD = ()=> STUD_PITCH;
const roundStud = v => Math.round(v/STD())*STD();

function anchorOffset(sx, sz, turns){
  const ox = -((sx-1)/2)*STD();
  const oz = -((sz-1)/2)*STD();
  const t = (turns & 3);
  if(t===0) return new THREE.Vector2(ox, oz);
  if(t===1) return new THREE.Vector2(-oz, ox);
  if(t===2) return new THREE.Vector2(-ox, -oz);
  return new THREE.Vector2(oz, -ox);
}
function bodyBoxWorld(mesh){
  mesh.updateWorldMatrix(true,false);
  const bb = mesh.geometry.boundingBox || (mesh.geometry.computeBoundingBox(), mesh.geometry.boundingBox);
  return bb.clone().applyMatrix4(mesh.matrixWorld);
}
function collides(mesh){
  const a=bodyBoxWorld(mesh);
  const half=(BASE_STUDS*STD())/2;
  if(a.min.x<-half || a.max.x>half || a.min.z<-half || a.max.z>half || a.min.y<0) return true;
  for(const c of modelRoot.children){
    if(!c.isMesh) continue;
    const b=bodyBoxWorld(c);
    if(a.max.x>b.min.x && a.min.x<b.max.x &&
       a.max.y>b.min.y && a.min.y<b.max.y &&
       a.max.z>b.min.z && a.min.z<b.max.z) return true;
  }
  return false;
}
function setGhostOK(ok){
  if(!ghost) return;
  ghost.traverse(o=>{
    if((o.isMesh || o.isInstancedMesh) && o.material){
      const m=o.material;
      if(ok){
        if(currentColor.glass){ m.transmission=1.0; m.ior=1.45; m.roughness=0.15; m.opacity=0.6; }
        else { m.transmission=0.0; m.roughness=0.6; m.opacity=0.6; }
        m.color.setHex(currentColor.hex);
      }else{
        m.color.setHex(0xC62828); m.transmission=0.0; m.opacity=0.55;
      }
      m.needsUpdate=true;
    }
  });
}

function startPlacing(key){
  const p=CATALOG[key]; if(!p) return;
  if(ghost){ scene.remove(ghost); ghost=null; }
  sourceKey=key;
  ghost=makePartMesh(key, currentColor, { ghost:true });
  scene.add(ghost); quarterTurns=0; hint.style.display='block'; clearSelection();
}
function cancelPlacing(){ if(ghost){ scene.remove(ghost); ghost=null; } sourceKey=null; quarterTurns=0; hint.style.display='none'; }

window.addEventListener('mousemove',(e)=>{
  const rect=renderer.domElement.getBoundingClientRect();
  mouse.x=((e.clientX-rect.left)/rect.width)*2-1; mouse.y=-((e.clientY-rect.top)/rect.height)*2+1;
  ray.setFromCamera(mouse,camera);
  if(!ghost) return;

  const sx = ghost.userData.studsX, sz = ghost.userData.studsZ, h=ghost.userData.height;
  const off = anchorOffset(sx, sz, quarterTurns);

  let cx=0, cz=0, cy=0;

  const hits=ray.intersectObjects(modelRoot.children,true);
  if(hits.length){
    let m = hits[0].object; while(m && (!m.isMesh || !m.userData?.height)) m = m.parent;
    if(m){
      const hit = hits[0].point;
      const studX = roundStud(hit.x);
      const studZ = roundStud(hit.z);
      const bbTop = bodyBoxWorld(m).max.y;
      cx = studX - off.x; cz = studZ - off.y; cy = bbTop + h/2 + EPS;
    }
  }

  if(cy===0){
    const ground=ray.intersectObject(pickPlane,false)[0];
    if(ground){
      const studX = roundStud(ground.point.x);
      const studZ = roundStud(ground.point.z);
      cx = studX - off.x; cz = studZ - off.y; cy = PLATE_HEIGHT + h/2;
    } else { return; }
  }

  ghost.position.set(cx,cy,cz);
  ghost.rotation.set(0,(quarterTurns&3)*(Math.PI/2),0);
  setGhostOK(!collides(ghost));
});

window.addEventListener('keydown',(e)=>{
  if(e.key.toLowerCase()==='r' && ghost){ quarterTurns=(quarterTurns+1)&3; }
  if(e.key==='Escape'){
    menuParts.classList.remove('show');
    menuColor.classList.remove('show');
    cancelPlacing();
  }
  if((e.key==='Delete'||e.key==='Backspace') && selected){
    modelRoot.remove(selected); clearSelection();
  }
});

window.addEventListener('mousedown',(e)=>{
  // placing: keep ghost alive for rapid-fire
  if(ghost && e.button===0){
    if(!collides(ghost)){
      const real=makePartMesh(sourceKey, currentColor);
      const sx=real.userData.studsX, sz=real.userData.studsZ, off=anchorOffset(sx,sz,quarterTurns);
      const centerX = roundStud(ghost.position.x + off.x) - off.x;
      const centerZ = roundStud(ghost.position.z + off.y) - off.y;
      real.position.set(centerX, ghost.position.y, centerZ);
      real.rotation.copy(ghost.rotation);
      modelRoot.add(real);
    }
    return;
  }

  // selection (simple)
  if(!ghost && e.button===0){
    const rect=renderer.domElement.getBoundingClientRect();
    const x=((e.clientX-rect.left)/rect.width)*2-1, y=-((e.clientY-rect.top)/rect.height)*2+1;
    const rc=new THREE.Raycaster(); rc.setFromCamera({x,y}, camera);
    const hits=rc.intersectObjects(modelRoot.children,true);
    if(hits.length){
      let m=hits[0].object; while(m && !m.userData?.id) m=m.parent;
      if(m) selectMesh(m);
    } else {
      clearSelection();
    }
  }
});

/* ===== render loop ===== */
function resize(){ const w=renderer.domElement.clientWidth, h=renderer.domElement.clientHeight; renderer.setSize(w,h,false); camera.aspect=w/h; camera.updateProjectionMatrix(); syncOutline(); }
renderer.setAnimationLoop(()=>{ controls.update(); resize(); renderer.render(scene,camera); });
</script>
</body>
</html>
